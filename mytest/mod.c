static void* __tvm_set_device_packed = NULL;
static void* myadd_kernel_packed = NULL;
int32_t myadd(void* args, int32_t* arg_type_ids, int32_t num_args, void* out_ret_value, int32_t* out_ret_tcode, void* resource_handle) {
  TVMValue stack[5];
  void* stack_tcode = stack;
  TVMValue stack_1[10];
  void* stack_value = stack_1;
  ICHECK((num_args == 3)) << "myadd: num_args should be 3";
  int32_t A_code = arg_type_ids[0];
  int32_t B_code = arg_type_ids[1];
  int32_t C_code = arg_type_ids[2];
  void* A = (((TVMValue*)args)[0].v_handle);
  void* B = (((TVMValue*)args)[1].v_handle);
  void* C = (((TVMValue*)args)[2].v_handle);
  void* A_1 = (((DLTensor*)A)[0].data);
  void* myadd_A_shape = (((DLTensor*)A)[0].shape);
  int32_t n = ((int32_t)((int64_t*)myadd_A_shape)[0]);
  void* myadd_A_strides = (((DLTensor*)A)[0].strides);
  int32_t stride = ((n == 1) ? 0 : ((myadd_A_strides == NULL) ? 1 : ((int32_t)((int64_t*)myadd_A_strides)[0])));
  int32_t dev_id = (((DLTensor*)A)[0].device.device_id);
  void* B_1 = (((DLTensor*)B)[0].data);
  void* myadd_B_shape = (((DLTensor*)B)[0].shape);
  void* myadd_B_strides = (((DLTensor*)B)[0].strides);
  int32_t stride_1 = ((n == 1) ? 0 : ((myadd_B_strides == NULL) ? 1 : ((int32_t)((int64_t*)myadd_B_strides)[0])));
  void* C_1 = (((DLTensor*)C)[0].data);
  void* myadd_C_shape = (((DLTensor*)C)[0].shape);
  void* myadd_C_strides = (((DLTensor*)C)[0].strides);
  int32_t stride_2 = ((n == 1) ? 0 : ((myadd_C_strides == NULL) ? 1 : ((int32_t)((int64_t*)myadd_C_strides)[0])));
  ICHECK(((((A_code == 3) || (A_code == 13)) || (A_code == 7)) || (A_code == 4))) << "myadd: Expect arg[0] to be pointer";
  ICHECK(((((B_code == 3) || (B_code == 13)) || (B_code == 7)) || (B_code == 4))) << "myadd: Expect arg[1] to be pointer";
  ICHECK(((((C_code == 3) || (C_code == 13)) || (C_code == 7)) || (C_code == 4))) << "myadd: Expect arg[2] to be pointer";
  ICHECK((1 == (((DLTensor*)A)[0].ndim))) << "myadd.A.ndim is expected to equal 1";
  ICHECK((1 == (((DLTensor*)A)[0].ndim))) << "myadd.A.ndim is expected to equal 1";
  ICHECK(((((((DLTensor*)A)[0].dtype.code) == (uint8_t)2) && ((((DLTensor*)A)[0].dtype.bits) == (uint8_t)32)) && ((((DLTensor*)A)[0].dtype.lanes) == (uint16_t)1))) << "myadd.A.dtype is expected to be float32";
  ICHECK(((uint64_t)0 == (((DLTensor*)A)[0].byte_offset))) << "Argument myadd.A.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(A, 0, 8, "uint64")";
  ICHECK(((((DLTensor*)A)[0].device.device_type) == 2)) << "Argument myadd.A.device_type has an unsatisfied constraint: 2 == T.tvm_struct_get(A, 0, 10, "int32")";
  ICHECK((1 == (((DLTensor*)B)[0].ndim))) << "myadd.B.ndim is expected to equal 1";
  ICHECK((1 == (((DLTensor*)B)[0].ndim))) << "myadd.B.ndim is expected to equal 1";
  ICHECK(((((((DLTensor*)B)[0].dtype.code) == (uint8_t)2) && ((((DLTensor*)B)[0].dtype.bits) == (uint8_t)32)) && ((((DLTensor*)B)[0].dtype.lanes) == (uint16_t)1))) << "myadd.B.dtype is expected to be float32";
  ICHECK((n == ((int32_t)((int64_t*)myadd_B_shape)[0]))) << "Argument myadd.B.shape[0] has an unsatisfied constraint: n == T.Cast("int32", myadd_B_shape[0])";
  ICHECK(((uint64_t)0 == (((DLTensor*)B)[0].byte_offset))) << "Argument myadd.B.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(B, 0, 8, "uint64")";
  ICHECK(((((DLTensor*)B)[0].device.device_type) == 2)) << "Argument myadd.B.device_type has an unsatisfied constraint: 2 == T.tvm_struct_get(B, 0, 10, "int32")";
  ICHECK((dev_id == (((DLTensor*)B)[0].device.device_id))) << "Argument myadd.B.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(B, 0, 9, "int32")";
  ICHECK((1 == (((DLTensor*)C)[0].ndim))) << "myadd.C.ndim is expected to equal 1";
  ICHECK((1 == (((DLTensor*)C)[0].ndim))) << "myadd.C.ndim is expected to equal 1";
  ICHECK(((((((DLTensor*)C)[0].dtype.code) == (uint8_t)2) && ((((DLTensor*)C)[0].dtype.bits) == (uint8_t)32)) && ((((DLTensor*)C)[0].dtype.lanes) == (uint16_t)1))) << "myadd.C.dtype is expected to be float32";
  ICHECK((n == ((int32_t)((int64_t*)myadd_C_shape)[0]))) << "Argument myadd.C.shape[0] has an unsatisfied constraint: n == T.Cast("int32", myadd_C_shape[0])";
  ICHECK(((uint64_t)0 == (((DLTensor*)C)[0].byte_offset))) << "Argument myadd.C.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(C, 0, 8, "uint64")";
  ICHECK(((((DLTensor*)C)[0].device.device_type) == 2)) << "Argument myadd.C.device_type has an unsatisfied constraint: 2 == T.tvm_struct_get(C, 0, 10, "int32")";
  ICHECK((dev_id == (((DLTensor*)C)[0].device.device_id))) << "Argument myadd.C.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(C, 0, 9, "int32")";
  (((TVMValue*)stack_value)[0].v_int64) = ((int64_t)2);
  ((int32_t*)stack_tcode)[0] = 0;
  (((TVMValue*)stack_value)[1].v_int64) = ((int64_t)dev_id);
  ((int32_t*)stack_tcode)[1] = 0;
  // Call packed function
  (((TVMValue*)stack_value)[0].v_handle) = A_1;
  ((int32_t*)stack_tcode)[0] = 3;
  (((TVMValue*)stack_value)[1].v_handle) = B_1;
  ((int32_t*)stack_tcode)[1] = 3;
  (((TVMValue*)stack_value)[2].v_handle) = C_1;
  ((int32_t*)stack_tcode)[2] = 3;
  (((TVMValue*)stack_value)[3].v_int64) = ((int64_t)n);
  ((int32_t*)stack_tcode)[3] = 0;
  (((TVMValue*)stack_value)[4].v_int64) = ((int64_t)stride_2);
  ((int32_t*)stack_tcode)[4] = 0;
  (((TVMValue*)stack_value)[5].v_int64) = ((int64_t)stride);
  ((int32_t*)stack_tcode)[5] = 0;
  (((TVMValue*)stack_value)[6].v_int64) = ((int64_t)stride_1);
  ((int32_t*)stack_tcode)[6] = 0;
  (((TVMValue*)stack_value)[7].v_int64) = ((int64_t)((n + 63) >> 6));
  ((int32_t*)stack_tcode)[7] = 0;
  (((TVMValue*)stack_value)[8].v_int64) = ((int64_t)64);
  ((int32_t*)stack_tcode)[8] = 0;
  // Call packed function
  return 0;
}

